#include <std/sys.pat>
#include <std/file.pat>

/*
==============================
TODO: SteeringWheel Mesh Layout
==============================
Based on observed tooling expectations (Vertices / Faces panel):

Vertices:
- Offset            : TODO (absolute + relative)
- Padding           : TODO
- Padding Interval  : TODO

Faces:
- Offset            : TODO (absolute + relative)
- Padding           : TODO
- Padding Interval  : TODO

Additional (if present):
- Normals Offset
- UV Offset
- Stride / rawP

Scope:
- Asset: SteeringWheel
- Location: ForestIndexes[0] -> DBEntries[4]
- Only offsets derived from this DBEntry are valid.
- No global assumptions.
==============================
*/

/*
    SiFF container layout (as used by the developers / runtime loader)

    In SSR_Wii.c, SiFF files are chunked. A ChunkHeader is:
        u32 id;
        u32 chunk_size;
        u32 data_size;
        u32 endian_indicator;

    In this particular .sif, there is an additional u32 before the first ChunkHeader
    which equals (total_file_size - 4). The first ChunkHeader begins at 0x04.

    Observed in BillyHatcher.sif:
      0x00: FileSizeMinus4
      0x04: ChunkHeader id = 'FORE'
      0x14: FORE payload begins (FileCount + ForestIndexEntry[])
*/

struct ChunkHeader {
    u32 id [[export]];              // e.g. 'FORE'
    u32 chunk_size [[export]];
    u32 data_size [[export]];
    u32 endian_indicator [[export]]; // typically 0x44332211 in this build
};

struct ForestIndexEntry {
    u32 ForestHash [[export]];
    u32 FileNamePtr [[export]];     // absolute file offset into concatenated name blob
    u32 ForestPtr [[export]];       // absolute file offset to ForestFile preamble
    u32 ForestZigOffset [[export]];
};

struct SiffPreamble {
    u32 FileSizeMinus4 [[export]];
    ChunkHeader FirstChunk [[export]];
};

// Minimal, safe globals used only for sizing logic
SiffPreamble gSiff @ 0x00 [[hidden]];

struct ForeIndexTable {
    u32 FileCount;

    const u32 FileCountCap = 64;
    u32 SafeFileCount = (FileCount < FileCountCap) ? FileCount : FileCountCap;

    ForestIndexEntry Index[SafeFileCount];
};

// FORE payload starts immediately after the first ChunkHeader (0x04 + 0x10 = 0x14)
ForeIndexTable gFore @ 0x14 [[hidden]];

fn getTotalFileSize() {
    return gSiff.FileSizeMinus4 + 4;
};

// Compute ForestFile size by looking at the next ForestPtr in the FORE index table.
fn getAssetSize() {
    u32 curForestPtr = $;

    for (u32 i = 0, i < gFore.SafeFileCount, i += 1) {
        if (curForestPtr == gFore.Index[i].ForestPtr) {
            if (i + 1 < gFore.SafeFileCount) {
                u32 nextPtr = gFore.Index[i + 1].ForestPtr;
                if (nextPtr > curForestPtr) {
                    return nextPtr - curForestPtr;
                }
                break;
            }

            u32 total = getTotalFileSize();
            if (total > curForestPtr) {
                return total - curForestPtr;
            }
            break;
        }
    }

    return 0;
};

fn getStrLen() {
    u8 i = 0;
    for (u32 pos = $, $ < pos + 64, $ += 1) {
        i += 1;
        u8 atpos @ $;
        if (atpos == 00) {
            return i; // includes the terminator byte in the count
        }
    }
    return 32;
};

struct ZigData {
    $ -= 22;
    u32 facesCount;
    u32 facesOffset;
    $ += 32;
    u32 rawP[[hidden]];
    u32 vertsCount;
    u32 vertsOffset;

    u32 vertsPadding = rawP - 12 [[export]];
    u32 normsOffset = vertsOffset + 12 [[export]];
    u32 normsPadding = rawP - 6 [[export]];
    u32 uvOffset = vertsOffset + 24 [[export]];
    u32 uvPadding = rawP - 4 [[export]];
};

fn isZigData() {
    $ += 0x80; // 5 rows
    for (u8 i = 0, i < 20, i += 1) {
        $ += 2;
        u48 test @ $;
        if (test == 281474976645120) { // 0x0001000000000000
            return $;
        }
        $ += 14;
    }
    return 0;
};

fn printn(auto num) {
    std::print("{}", num);
};

/*
    SAFE print2:
    - MUST be called with the maximum valid length of str2 (array length).
    - Never reads beyond that length.
    - Sanitizes to printable ASCII.
*/
fn print2(auto prefix, auto str2, u32 maxLen) {
    u32 cap = maxLen;

    if (cap > 256) {
        cap = 256;
    }

    u32 len = 0;

    // pass 1: bounded length scan
    for (u32 i = 0, i < cap, i += 1) {
        if (str2[i] == 0x00) {
            break;
        }
        len += 1;
    }

    // always allocate at least 1 char (+ terminator)
    char safe[len + 1];

    // pass 2: sanitize + copy
    for (u32 i = 0, i < len, i += 1) {
        u8 c = str2[i];
        if (c >= 0x20 && c <= 0x7E) {
            safe[i] = str2[i];
        } else {
            safe[i] = '.';
        }
    }

    // terminator
    safe[len] = 0x00;

    std::print("{}{}", prefix, safe);
};

/*
    Returns 1 if the name contains the substring "SteeringWheel".
    Performs a bounded substring search within maxLen.
*/
fn containsSteeringWheel(auto str2, u32 maxLen) {
    // "SteeringWheel" length = 13
    if (maxLen < 13) {
        return 0;
    }

    for (u32 i = 0, i + 13 <= maxLen, i += 1) {
        if (str2[i + 0]  != 'S') continue;
        if (str2[i + 1]  != 't') continue;
        if (str2[i + 2]  != 'e') continue;
        if (str2[i + 3]  != 'e') continue;
        if (str2[i + 4]  != 'r') continue;
        if (str2[i + 5]  != 'i') continue;
        if (str2[i + 6]  != 'n') continue;
        if (str2[i + 7]  != 'g') continue;
        if (str2[i + 8]  != 'W') continue;
        if (str2[i + 9]  != 'h') continue;
        if (str2[i + 10] != 'e') continue;
        if (str2[i + 11] != 'e') continue;
        if (str2[i + 12] != 'l') continue;
        return 1;
    }

    return 0;
};

/*
    SuBranch (SSR Wii) – serialized scene node header

    Matches struct SuBranch from SSR_Wii.c:
      u16 parent, child, sibling, flags
      u32 hash
      char* name
      SuBlindData* blind

    In SiFF, pointers are stored as relative offsets.
    Some builds store an extra pointer immediately after SuBranch
    at +0x14, used here as RenderPtrRel.
*/
struct SuBranchHeader {
    u16 ParentIdx     [[export]];
    u16 ChildIdx      [[export]];
    u16 SiblingIdx    [[export]];
    u16 BranchFlags   [[export]];

    u32 HashValue     [[export]];
    u32 NamePtrRel    [[export]];
    u32 BlindPtrRel   [[export]];

    // Observed extra pointer at +0x14 (immediately after SuBranch)
    u32 RenderPtrRel  [[export]];
};

struct SuBlindElement {
    u32 InstanceHash [[export]];
    u32 TypeHash     [[export]];
    u32 DataPtrRel   [[export]];
};

struct SuBlindData<auto Offset, auto FileSize> {
    u32 ElementQty [[export]];

    const u32 ElementCap = 8;
    u32 SafeQty = (ElementQty < ElementCap) ? ElementQty : ElementCap;

    SuBlindElement Elements[SafeQty] [[export]];
};

/*
    SAFE Mesh descriptor probe:
    Jump to offsets without big padding arrays.
*/
struct MeshDescProbe<auto Offset> {
    // This probe reads the engine render-mesh descriptor block.
    // It is only valid when called on the correct RenderPtrRel base.
    u32 ProbeBase = $ [[export]];

    $ = ProbeBase + 0xCC;
    u32 facesCount [[export]];
    u32 facesOffsetRel [[export]];
    u32 unkD4 [[hidden]];

    $ = ProbeBase + 0xF4;
    u32 rawP_stride [[export]];
    u32 vertsCount [[export]];
    u32 vertsOffsetRel [[export]];

    u32 vertsPaddingAfterXYZ = rawP_stride - 12 [[export]];
    u32 facesOffsetAbs = facesOffsetRel + Offset [[export]];
    u32 vertsOffsetAbs = vertsOffsetRel + Offset [[export]];

    // keep cursor sane
    $ = ProbeBase + 0x100;
};

/*
    Tree walker (correct behaviour):
    - SteeringWheel can be a grouping node.
    - The mesh often lives on a descendant branch.

    This function walks Child/Sibling links starting from RootIdx,
    prints each visited node, and probes RenderPtrRel and BlindData
    for plausible render-mesh descriptors.

    Hard-bounded to avoid ImHex hangs.
*/
fn walkBranchTree(auto Offset, u32 FileSize, u32 DBEntryPtrRel, u32 RootIdx) {
    const u32 MaxNodes = 64;

    u32 stack[MaxNodes];
    u32 sp = 0;

    u32 visited[MaxNodes];
    u32 visitedN = 0;

    // push root
    stack[0] = RootIdx;
    sp = 1;

    std::print("\n=== BranchTreeWalk (RootIdx: {}) ===\n", RootIdx);

    for (u32 iter = 0, iter < MaxNodes, iter += 1) {
        if (sp == 0) {
            break;
        }

        sp -= 1;
        u32 idx = stack[sp];

        // seen check
        u32 seen = 0;
        for (u32 vi = 0, vi < visitedN, vi += 1) {
            if (visited[vi] == idx) {
                seen = 1;
                break;
            }
        }
        if (seen == 1) {
            continue;
        }
        visited[visitedN] = idx;
        visitedN += 1;

        // read DBEOffsetPtrRel from branch pointer table (m_ppBranches)
        // Pointers are typically relative to ForestFile base (Offset), but some builds may already be absolute.
        u32 DBEOffsetPtrRel;

        // primary interpretation: table is relative -> absolute = DBEntryPtrRel + Offset
        $ = DBEntryPtrRel + Offset + idx * 4;
        u32 offA;

        // fallback interpretation: table is already absolute (no additional Offset)
        u32 offB = 0;
        if (offA == 0) {
            if (DBEntryPtrRel >= Offset && DBEntryPtrRel < Offset + FileSize) {
                $ = DBEntryPtrRel + idx * 4;
                u32 offB_read;
                offB = offB_read;
            }
        }

        DBEOffsetPtrRel = (offA != 0) ? offA : offB;

        if (DBEOffsetPtrRel == 0 || DBEOffsetPtrRel >= FileSize) {
            std::print("Node[{}]: invalid DBEOffsetPtrRel {} (offA={}, offB={})\n", idx, DBEOffsetPtrRel, offA, offB);
            continue;
        }

        u32 DBEOffsetAbs = DBEOffsetPtrRel + Offset;
        $ = DBEOffsetAbs;
        SuBranchHeader BH;

        // name (bounded)
        std::print("Node[{}] P:{} C:{} S:{} Flags:{} Hash:{}\n",
            idx, BH.ParentIdx, BH.ChildIdx, BH.SiblingIdx, BH.BranchFlags, BH.HashValue);
        std::print("  BlindPtrRel:{} RenderPtrRel:{}\n", BH.BlindPtrRel, BH.RenderPtrRel);

        if (BH.NamePtrRel != 0 && BH.NamePtrRel < FileSize) {
            $ = BH.NamePtrRel + Offset;
            u8 nlen = getStrLen();
            char nm[nlen];
            print2("  Name: ", nm, nlen);
            std::print("\n");
        } else {
            std::print("  Name: <invalid ptr>\n");
        }

        // Probe RenderPtrRel as mesh descriptor
        if (BH.RenderPtrRel != 0 && (BH.RenderPtrRel % 16) == 0 && BH.RenderPtrRel < FileSize) {
            $ = BH.RenderPtrRel + Offset;
            MeshDescProbe<Offset> MP;

            std::print("  [RenderPtr] facesCount:{} vertsCount:{}\n", MP.facesCount, MP.vertsCount);
            std::print("  [RenderPtr] facesOffsetAbs:{} vertsOffsetAbs:{}\n", MP.facesOffsetAbs, MP.vertsOffsetAbs);
        }

        // Probe BlindData elements (limited)
        if (BH.BlindPtrRel != 0 && (BH.BlindPtrRel % 4) == 0 && BH.BlindPtrRel < FileSize) {
            $ = BH.BlindPtrRel + Offset;
            SuBlindData<Offset, FileSize> BD;

            std::print("  [BlindData] ElementQty:{} (showing up to 8)\n", BD.ElementQty);

            for (u32 ei = 0, ei < BD.SafeQty, ei += 1) {
                std::print("    Elem[{}] instHash:{} typeHash:{} dataRel:{}\n",
                    ei, BD.Elements[ei].InstanceHash, BD.Elements[ei].TypeHash, BD.Elements[ei].DataPtrRel);

                // Optional: probe element data pointer as mesh descriptor
                if (BD.Elements[ei].DataPtrRel != 0 && (BD.Elements[ei].DataPtrRel % 16) == 0 && BD.Elements[ei].DataPtrRel < FileSize) {
                    $ = BD.Elements[ei].DataPtrRel + Offset;
                    MeshDescProbe<Offset> MP2;
                    std::print("      [ElemData] facesCount:{} vertsCount:{}\n", MP2.facesCount, MP2.vertsCount);
                }
            }
        }

        // push child then sibling (DFS), respecting 0xFFFF sentinel
        if (BH.SiblingIdx != 0xFFFF && sp < MaxNodes) {
            stack[sp] = BH.SiblingIdx;
            sp += 1;
        }
        if (BH.ChildIdx != 0xFFFF && sp < MaxNodes) {
            stack[sp] = BH.ChildIdx;
            sp += 1;
        }
    }

    std::print("=== BranchTreeWalk END (visited {}) ===\n", visitedN);
};

struct DBEntry<auto Offset> {
    u32 start = $;

    u32 DBEOffsetPtr [[export]];
    u32 DBEOffsetAbs = DBEOffsetPtr + Offset [[export]];

    // header at DBEOffsetPtr
    $ = DBEOffsetAbs;
    SuBranchHeader Hdr [[export]];

    // Name ptr + string
    u32 DBENamePtr = Hdr.NamePtrRel [[export]];

    $ = DBENamePtr + Offset;
    u8   DBENameLen = getStrLen();
    char DBEName[DBENameLen];

    u32 DebugSteeringWheel = containsSteeringWheel(DBEName, DBENameLen) [[export]];

    if (DebugSteeringWheel == 1) {
        std::print("\n=== DEBUG: SteeringWheel ===\n");
        std::print("DBEOffsetPtrRel: {}\n", DBEOffsetPtr);
        std::print("DBEOffsetAbs:    {}\n", DBEOffsetAbs);

        std::print("NamePtrRel:      {}\n", Hdr.NamePtrRel);
        std::print("NamePtrAbs:      {}\n", Hdr.NamePtrRel + Offset);

        std::print("BlindPtrRel:     {}\n", Hdr.BlindPtrRel);
        std::print("BlindPtrAbs:     {}\n", Hdr.BlindPtrRel + Offset);

        std::print("RenderPtrRel:    {}\n", Hdr.RenderPtrRel);
        std::print("RenderPtrAbs:    {}\n", Hdr.RenderPtrRel + Offset);

        std::print("ParentIdx:       {}\n", Hdr.ParentIdx);
        std::print("ChildIdx:        {}\n", Hdr.ChildIdx);
        std::print("SiblingIdx:      {}\n", Hdr.SiblingIdx);
        std::print("BranchFlags:     {}\n", Hdr.BranchFlags);
        std::print("HashValue:       {}\n", Hdr.HashValue);

        // legacy labels preserved (your logs referenced them)
        std::print("DataPtrRel:      {}\n", Hdr.RenderPtrRel);
        std::print("DataPtrAbs:      {}\n", Hdr.RenderPtrRel + Offset);

        std::print("NameLen(raw):    {}\n", DBENameLen);
        print2("Name:            ", DBEName, DBENameLen);
        std::print("\n");
    }

    // Render pointer (immediately after SuBranch). Often NULL for grouping/instance nodes.
    u32 DBETestDataPtr = Hdr.RenderPtrRel [[hidden]];

    if (DebugSteeringWheel == 1) {
        std::print("DBETestDataPtrRel(read@DBEOffset+0x14): {}\n", DBETestDataPtr);
        std::print("DBETestDataPtrAbs:                      {}\n", DBETestDataPtr + Offset);
    }

    // Optional: ZigData signature probe at RenderPtrRel (works only if RenderPtrRel points at/near ZigData)
    if (DBETestDataPtr % 16 == 0) {
        $ = DBETestDataPtr + Offset;

        u32 TestOffset = isZigData();

        if (DebugSteeringWheel == 1) {
            std::print("isZigData() returned (cursor): {}\n", TestOffset);
        }

        if (TestOffset != 0) {
            u32 ZigDataPos = TestOffset [[export]];

            if (DebugSteeringWheel == 1) {
                std::print("ZigDataPosRel: {}\n", ZigDataPos);
                std::print("ZigDataPosAbs: {}\n", ZigDataPos + Offset);
            }

            $ = ZigDataPos + Offset;
            ZigData DBEData;

            print2("Succeeded:", DBEName, DBENameLen);

            if (DebugSteeringWheel == 1) {
                std::print("\n--- ZigData (SteeringWheel) ---\n");
                std::print("facesCount: {}\n", DBEData.facesCount);
                std::print("facesOffsetRel: {}\n", DBEData.facesOffset);
                std::print("facesOffsetAbs: {}\n", DBEData.facesOffset + Offset);
                std::print("vertsCount: {}\n", DBEData.vertsCount);
                std::print("vertsOffsetRel: {}\n", DBEData.vertsOffset);
                std::print("vertsOffsetAbs: {}\n", DBEData.vertsOffset + Offset);
                std::print("rawP/stride: (hidden field in ZigData)\n");
                std::print("vertsPadding: {}\n", DBEData.vertsPadding);
                std::print("normsOffsetAbs: {}\n", DBEData.normsOffset + Offset);
                std::print("uvOffsetAbs: {}\n", DBEData.uvOffset + Offset);
                std::print("==========================\n");
            }
        } else {
            print2("Failed:", DBEName, DBENameLen);

            if (DebugSteeringWheel == 1) {
                std::print("\n--- ZigData FAIL (SteeringWheel) ---\n");
                std::print("No ZigData signature detected at DBETestDataPtrAbs.\n");
                std::print("===============================\n");
            }
        }
    } else {
        if (DebugSteeringWheel == 1) {
            std::print("\n--- ZigData SKIP (SteeringWheel) ---\n");
            std::print("DBETestDataPtrRel not 16-aligned.\n");
            std::print("===============================\n");
        }
    }

    // Probe RenderPtrRel safely as mesh descriptor
    if (Hdr.RenderPtrRel != 0 && (Hdr.RenderPtrRel % 16) == 0) {
        $ = Hdr.RenderPtrRel + Offset;
        MeshDescProbe<Offset> MeshProbe [[export]];

        if (DebugSteeringWheel == 1) {
            std::print("\n--- MeshDescProbe (SteeringWheel) ---\n");
            std::print("ProbeBaseAbs: {}\n", MeshProbe.ProbeBase);
            std::print("facesCount: {}\n", MeshProbe.facesCount);
            std::print("facesOffsetRel: {}\n", MeshProbe.facesOffsetRel);
            std::print("facesOffsetAbs: {}\n", MeshProbe.facesOffsetAbs);
            std::print("rawP_stride: {}\n", MeshProbe.rawP_stride);
            std::print("vertsCount: {}\n", MeshProbe.vertsCount);
            std::print("vertsOffsetRel: {}\n", MeshProbe.vertsOffsetRel);
            std::print("vertsOffsetAbs: {}\n", MeshProbe.vertsOffsetAbs);
            std::print("vertsPaddingAfterXYZ: {}\n", MeshProbe.vertsPaddingAfterXYZ);
            std::print("===============================\n");
        }
    } else {
        if (DebugSteeringWheel == 1) {
            std::print("\n--- MeshDescProbe SKIP (SteeringWheel) ---\n");
            std::print("Hdr.RenderPtrRel is 0 or not 16-aligned.\n");
            std::print("=====================================\n");
        }
    }

    $ = start + 4;
};

/*
    SIF ("SiFF") research notes – DBEntryPtr descriptor table

    Cross-checks against multiple ForestFiles show DBEntryPtr
    targets a multi-purpose scene descriptor, not raw data.

    Observed invariant properties:
    - Section A offsets always point to valid branch headers
    - Section B count matches number of instance-like nodes
    - Section C count is constant (usually 3), implying fixed scene layers
*/
struct DataBranch<auto Offset> {
    u32 DBSize;
    u32 DBEntryPtr;

    /*
        CRITICAL SAFETY NOTE (ImHex memory explosion fix):
        hard-cap the number of DBEntries parsed.
    */
    const u32 DBSizeCap = 5;
    u32 SafeDBSize = (DBSize < DBSizeCap) ? DBSize : DBSizeCap;

    // Jump into entry-offset list
    $ = DBEntryPtr + Offset;

    DBEntry<Offset> DBEntries[SafeDBSize];

    // Identify SteeringWheel within the materialized window
    // (ImHex does not allow for-loops as struct members; unrolled checks)
    u32 SteeringWheelFound = 0 [[export]];
    u32 SteeringWheelIndex = 0xFFFFFFFF [[export]];

    if (SafeDBSize > 0 && DBEntries[0].DebugSteeringWheel == 1) {
        SteeringWheelFound = 1;
        SteeringWheelIndex = 0;
    } else if (SafeDBSize > 1 && DBEntries[1].DebugSteeringWheel == 1) {
        SteeringWheelFound = 1;
        SteeringWheelIndex = 1;
    } else if (SafeDBSize > 2 && DBEntries[2].DebugSteeringWheel == 1) {
        SteeringWheelFound = 1;
        SteeringWheelIndex = 2;
    } else if (SafeDBSize > 3 && DBEntries[3].DebugSteeringWheel == 1) {
        SteeringWheelFound = 1;
        SteeringWheelIndex = 3;
    } else if (SafeDBSize > 4 && DBEntries[4].DebugSteeringWheel == 1) {
        SteeringWheelFound = 1;
        SteeringWheelIndex = 4;
    }
};

struct TBEntry<auto Offset> {
    u32 start = $;

    u32 TBENameOffsetPtr;

    $ = TBENameOffsetPtr + Offset;
    u32 TBENamePtr;
    $ += 4;
    u32 TBEZigOffset;

    $ =  TBENamePtr + Offset;
    u8   TBENameLen = getStrLen();
    char TBEName[TBENameLen];

    $ = start + 4;
};

struct TexBranch<auto size, auto Offset> {
    u32 TBSize = size;
    TBEntry<Offset> TBEntries[TBSize];
};

struct ForestHeader<auto Offset> {
    u32 NCount;
    $ += 4;
    u32 TBSize;
    $ += 8;
    u32;
    $ += 12;
    u32 DBPtr;

    $ = 40 + NCount * 4 - 4 + Offset;
};

struct ForestFile {
    u32 FileSize = getAssetSize();
    $ = $ + 20;
    u32 FileEOff = $ + FileSize;

    u32 Offset = $;

    ForestHeader<Offset> Header;
    TexBranch<Header.TBSize, Offset> TB;

    $ = Header.DBPtr + 8 + Offset;
    DataBranch<Offset> DB;

    // Correct behaviour: SteeringWheel may be a grouping branch.
    // Walk descendants to locate actual renderable mesh owners.
    if (DB.SteeringWheelFound == 1) {
        walkBranchTree(Offset, FileSize, DB.DBEntryPtr, DB.SteeringWheelIndex);
    }

    $ = FileEOff - 4;
    u32 FileEnd;
};

struct ForestIndex {
    // Exact 16-byte index entry as stored in the FORE payload
    u32 ForestHash [[export]];
    u32 FileNamePtr [[export]];
    u32 ForestPtr [[export]];
    u32 ForestZigOffset [[export]];

    // Resolve filename from the concatenated name blob.
    // The first name is preceded by 20 bytes of zeros; subsequent names are contiguous.
    u32 _ret_after_entry = $ [[hidden]];

    $ = FileNamePtr;
    u32 z0; u32 z1; u32 z2; u32 z3; u32 z4;

    // NOTE: Avoid assignment statements inside structs (would attempt to write to the file).
    // Compute NameAbs as a local/calculated value via initializer.
    u32 NameAbs = ((z0 == 0 && z1 == 0 && z2 == 0 && z3 == 0 && z4 == 0) ? (FileNamePtr + 20) : FileNamePtr) [[hidden]];

    $ = NameAbs;
    u8   NameLen = getStrLen();
    char FileName[NameLen] [[export]];

    // Parse the referenced ForestFile
    $ = ForestPtr;
    ForestFile File;

    // restore cursor to the end of this index entry
    $ = _ret_after_entry;
};

struct SiffFile {
    // File preamble
    u32 FileSizeMinus4 [[export]];
    ChunkHeader ForeChunkHeader [[export]]; // first chunk header (expected id 'FORE')

    // FORE chunk payload
    u32 FileCount [[export]];

    const u32 FileCountCap = 64;
    u32 SafeFileCount = (FileCount < FileCountCap) ? FileCount : FileCountCap;

    ForestIndex ForestIndexes[SafeFileCount] [[export]];
};

SiffFile SiffFileView @ 0x00;
